
--- grammar

grammar;

use std::collections::BTreeMap;
use crate::ast::BosonogaItem;

match {
    r"(?i)TALI"  => TALI_KW,
    r"(?i)DI"    => DI_KW,
    r"(?i)DO"    => DO_KW,
    r"(?i)VAL"   => VAL_KW,
    r"(?i)INAT"  => INAT_KW,
    r"(?i)ADA"   => ADA_KW,
    r"(?i)FUNAK" => FUNAK_KW,
    r"(?i)VEDA"  => VEDA_KW,
} else {
    r"[a-z]+"   => ID_NAMA,
    r"[0-9]+"   => NUM_NAMA,
}

pub Bosonoga: i32 = {
    <items:BosonogaItem*> => {
        let mut map: BTreeMap<String, i32> = BTreeMap::new();
        let mut functions: BTreeMap<String, BTreeMap<String, i32>> = BTreeMap::new();

        for item in items {
            match item {
                BosonogaItem::Set(key, amount) => {
                    *map.entry(key).or_insert(0) += amount;
                }
                BosonogaItem::Tali => {
                    println!("{:?}", map);
                }
                BosonogaItem::Funak(name) => {
                    functions.insert(name, map.clone());
                }
                BosonogaItem::Veda(name) => {
                    if functions.contains_key(&name) {
                        println!("{}", name);
                    } else {
                        panic!("Undefined function: {}", name);
                    }
                }
            }
        }

        map.values().copied().sum()
    }
};

BosonogaItem: BosonogaItem = {
    Tali => BosonogaItem::Tali,

    FunakKw <name:BosonogaVariableName>
        => BosonogaItem::Funak(name.to_string()),

    VedaKw <name:BosonogaVariableName>
        => BosonogaItem::Veda(name.to_string()),

    <ident:BosonogaIdentifier> => BosonogaItem::Set(ident.0, ident.1),
};

Tali: () = {
    TALI_KW => ()
};
DiKw:    () = { DI_KW    => () };
DoKw:    () = { DO_KW    => () };
ValKw:   () = { VAL_KW   => () };
InatKw:  () = { INAT_KW  => () };
AdaKw:   () = { ADA_KW   => () };
FunakKw: () = { FUNAK_KW => () };
VedaKw:  () = { VEDA_KW  => () };

BosonogaVariableType: &'input str = {
    InatKw => "INAT",
};

BosonogaVariableName: &'input str = {
    ID_NAMA => <>,
};

BosonogaVariableValue: i32 = {
    <n:BosonogaNumber> => n,
};

BosonogaNumber: i32 = {
    NUM_NAMA => <>.parse::<i32>().unwrap()
};

BosonogaIdentifier: (String, i32) = {
    DiKw  => ("DI".to_string(), 100),
    DoKw  => ("DO".to_string(), 1),
    ValKw <ty:BosonogaVariableType> <name:BosonogaVariableName> <value:BosonogaVariableValue>
        => (name.to_string(), value),
    AdaKw <name:BosonogaVariableName> <value:BosonogaVariableValue>
        => (name.to_string(), value),
};

--- tests

use crate::bosonoga::BosonogaParser;
use pretty_assertions::assert_eq;

#[test]
fn test_bosonoga_tali() {
    println!("test_bosonoga_tali");
    let input = r"
        DI
        DO
        DI
        TALI
    ";
    let parser = BosonogaParser::new();
    let bosonoga = parser.parse(input).unwrap();
    assert_eq!(bosonoga, 201);
}

#[test]
fn test_bosonoga_bul_inat() {
    println!("test_bosonoga_inat TODO bul");
    let input = r"
        DI
        DO
        DI
        VAL INAT first 50
        ADA first 49
        TALI
    ";
    let parser = BosonogaParser::new();
    let bosonoga = parser.parse(input).unwrap();
    assert_eq!(bosonoga, 300);
}

#[test]
fn test_funak_veda() {
    println!("test_funak_veda");
    let input = r"
        DI
        FUNAK fnfirst
        DO
        VEDA fnfirst
        DI
        TALI
    ";
    let parser = BosonogaParser::new();
    let bosonoga = parser.parse(input).unwrap();
    assert_eq!(bosonoga, 201);
}

--- ast

#[derive(Debug)]
pub enum BosonogaItem {
    Set(String, i32),
    Tali,
    Funak(String),
    Veda(String),
}

--- main

use lalrpop_util::lalrpop_mod;

lalrpop_mod!(pub bosonoga);

mod ast;

#[cfg(test)]
mod tests;

fn main() {
    println!("<START>");
    println!("<END>");
}
